/******************************************************************************
 * This file was generated by langium-cli 1.0.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

/* eslint-disable */
import { AstNode, AbstractAstReflection, Reference, ReferenceInfo, TypeMetaData } from 'langium';

export type Brick = Actuator | LCD | Sensor;

export const Brick = 'Brick';

export function isBrick(item: unknown): item is Brick {
    return reflection.isInstance(item, Brick);
}

export type MessagePart = BrickStatusPart | ConstantPart;

export const MessagePart = 'MessagePart';

export function isMessagePart(item: unknown): item is MessagePart {
    return reflection.isInstance(item, MessagePart);
}

export interface Action extends AstNode {
    readonly $container: State;
    readonly $type: 'Action';
    actuator: Reference<Actuator>
    value: Signal
}

export const Action = 'Action';

export function isAction(item: unknown): item is Action {
    return reflection.isInstance(item, Action);
}

export interface Actuator extends AstNode {
    readonly $container: App;
    readonly $type: 'Actuator';
    name: string
    outputPin: number
}

export const Actuator = 'Actuator';

export function isActuator(item: unknown): item is Actuator {
    return reflection.isInstance(item, Actuator);
}

export interface App extends AstNode {
    readonly $type: 'App';
    bricks: Array<Brick>
    initial: Reference<State>
    name: string
    states: Array<State>
}

export const App = 'App';

export function isApp(item: unknown): item is App {
    return reflection.isInstance(item, App);
}

export interface BrickStatusPart extends AstNode {
    readonly $container: LCDAction;
    readonly $type: 'BrickStatusPart';
    brick: Reference<Brick>
}

export const BrickStatusPart = 'BrickStatusPart';

export function isBrickStatusPart(item: unknown): item is BrickStatusPart {
    return reflection.isInstance(item, BrickStatusPart);
}

export interface Condition extends AstNode {
    readonly $container: Transition;
    readonly $type: 'Condition';
    sensor: Reference<Sensor>
    value: Signal
}

export const Condition = 'Condition';

export function isCondition(item: unknown): item is Condition {
    return reflection.isInstance(item, Condition);
}

export interface ConstantPart extends AstNode {
    readonly $container: LCDAction;
    readonly $type: 'ConstantPart';
    text: string
}

export const ConstantPart = 'ConstantPart';

export function isConstantPart(item: unknown): item is ConstantPart {
    return reflection.isInstance(item, ConstantPart);
}

export interface LCD extends AstNode {
    readonly $container: App;
    readonly $type: 'LCD';
    name: string
}

export const LCD = 'LCD';

export function isLCD(item: unknown): item is LCD {
    return reflection.isInstance(item, LCD);
}

export interface LCDAction extends AstNode {
    readonly $container: State;
    readonly $type: 'LCDAction';
    lcd: Reference<LCD>
    parts: Array<MessagePart>
}

export const LCDAction = 'LCDAction';

export function isLCDAction(item: unknown): item is LCDAction {
    return reflection.isInstance(item, LCDAction);
}

export interface Sensor extends AstNode {
    readonly $container: App;
    readonly $type: 'Sensor';
    inputPin: number
    name: string
}

export const Sensor = 'Sensor';

export function isSensor(item: unknown): item is Sensor {
    return reflection.isInstance(item, Sensor);
}

export interface Signal extends AstNode {
    readonly $container: Action | Condition;
    readonly $type: 'Signal';
    value: string
}

export const Signal = 'Signal';

export function isSignal(item: unknown): item is Signal {
    return reflection.isInstance(item, Signal);
}

export interface State extends AstNode {
    readonly $container: App;
    readonly $type: 'State';
    actions: Array<Action | LCDAction>
    name: string
    transition: Transition
}

export const State = 'State';

export function isState(item: unknown): item is State {
    return reflection.isInstance(item, State);
}

export interface Transition extends AstNode {
    readonly $container: State;
    readonly $type: 'Transition';
    conditions: Array<Condition>
    next: Reference<State>
    operator: Array<'and' | 'or'>
}

export const Transition = 'Transition';

export function isTransition(item: unknown): item is Transition {
    return reflection.isInstance(item, Transition);
}

export interface ArduinoMlAstType {
    Action: Action
    Actuator: Actuator
    App: App
    Brick: Brick
    BrickStatusPart: BrickStatusPart
    Condition: Condition
    ConstantPart: ConstantPart
    LCD: LCD
    LCDAction: LCDAction
    MessagePart: MessagePart
    Sensor: Sensor
    Signal: Signal
    State: State
    Transition: Transition
}

export class ArduinoMlAstReflection extends AbstractAstReflection {

    getAllTypes(): string[] {
        return ['Action', 'Actuator', 'App', 'Brick', 'BrickStatusPart', 'Condition', 'ConstantPart', 'LCD', 'LCDAction', 'MessagePart', 'Sensor', 'Signal', 'State', 'Transition'];
    }

    protected override computeIsSubtype(subtype: string, supertype: string): boolean {
        switch (subtype) {
            case Actuator:
            case LCD:
            case Sensor: {
                return this.isSubtype(Brick, supertype);
            }
            case BrickStatusPart:
            case ConstantPart: {
                return this.isSubtype(MessagePart, supertype);
            }
            default: {
                return false;
            }
        }
    }

    getReferenceType(refInfo: ReferenceInfo): string {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Action:actuator': {
                return Actuator;
            }
            case 'App:initial':
            case 'Transition:next': {
                return State;
            }
            case 'BrickStatusPart:brick': {
                return Brick;
            }
            case 'Condition:sensor': {
                return Sensor;
            }
            case 'LCDAction:lcd': {
                return LCD;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }

    getTypeMetaData(type: string): TypeMetaData {
        switch (type) {
            case 'App': {
                return {
                    name: 'App',
                    mandatory: [
                        { name: 'bricks', type: 'array' },
                        { name: 'states', type: 'array' }
                    ]
                };
            }
            case 'LCDAction': {
                return {
                    name: 'LCDAction',
                    mandatory: [
                        { name: 'parts', type: 'array' }
                    ]
                };
            }
            case 'State': {
                return {
                    name: 'State',
                    mandatory: [
                        { name: 'actions', type: 'array' }
                    ]
                };
            }
            case 'Transition': {
                return {
                    name: 'Transition',
                    mandatory: [
                        { name: 'conditions', type: 'array' },
                        { name: 'operator', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}

export const reflection = new ArduinoMlAstReflection();
